#!/usr/bin/perl

use strict;
use Getopt::Long;
use POSIX "uname";

my $VERSION    = '1.4.0';

my $tmp        = '/tmp/check_diskio_status';
my $name       = "DISKIO";

my $critical   = 0;
my $help       = '';
my $device     = '';
my $reset      = '';
my $result;
my $status     = 0;
my $status_msg = '';
my $warning    = 0;
my $silent     = '';

##############################################################################
# subroutines

################################
# prints the usage of the plugin
sub usage {
  my $msg = shift;

  if (defined $msg) {
    print "$msg\n";
  }

  print << "EOT";
usage:
  -c crit, --critical=crit      critical
  -d device, --device=device    device name
  -r, --reset                   reset the counter
  -s, --silent                  no warnings or critials
  -v, --version                 version
  -w warn, --warning warn       warning

  either -c and -w or -s have to be specified
EOT
  exit(3);
}

#################################################
# prints an "unknown" error message (exit code 3)
sub unknown {

  my $msg = shift;

  if (defined $msg) {
    print "$name UNKNOWN: $msg\n";
  }

  exit(3);

}

#################################################
# writes the time and transmit data to
# the temporary file
sub write_timer {

    my $in  = shift;
    my $out = shift;

    open(TMP, "> $tmp") or
        unknown("Cannot initialize timer");
    print TMP time . " $in $out\n";
    close TMP or
        unknown("Cannot close timer");
}

#################################################
# detects the Linux kernel version
sub kernel_version {

  my ($sysname, $nodename, $release, $version, $machine ) = uname;
  if ($release =~ /^2.4/) {
    return "2.4";
  }
  if ($release =~ /^2.6/) {
    return "2.6";
  }

  unknown "kernel version ($release)";

}

#################################################
# reads kernel 2.6 disk stats
sub read_26 {

  my $device = shift;

  open(IN, '/proc/diskstats') or
    unknown("Cannot open /proc/diskstats");

  while(<IN>) {

    chomp;

    # kernel version 2.6

    # /proc/diskstats format
    #
    # major         Major number
    # minor         Minor number
    # name          Name
    # reads         This is the total number of reads completed successfully.
    # merged        Reads and writes which are adjacent to each other may be merged for
    #               efficiency.  Thus two 4K reads may become one 8K read before it is
    #               ultimately handed to the disk, and so it will be counted (and queued)
    #               as only one I/O.  This field lets you know how often this was done.
    # s_read        This is the total number of sectors read successfully.
    # ms_read       This is the total number of milliseconds spent by all reads.
    # writes        This is the total number of writes completed successfully.
    # s_write       This is the total number of sectors written successfully.
    # ms_write      This is the total number of milliseconds spent by all writes.
    # ios           The only field that should go to zero. Incremented as requests are
    #               given to appropriate request_queue_t and decremented as they finish.
    # ms_io         This field is increases so long as field 9 is nonzero.
    # ms_weighted   This field is incremented at each I/O start, I/O completion, I/O
    #               merge, or read f these stats by the number of I/Os in progress
    #               times the number of milliseconds spent doing I/O since the
    #               last update of this field.  This can provide an easy measure of both
    #               I/O completion time and the backlog that may be accumulating.

    my ($major,
        $minor,
        $name,
        $reads,
        $merge_read,
        $s_read,
        $ms_read,
        $writes,
        $merge_write,
        $s_write,
        $ms_write,
        $ios,
        $ms_io,
        $ms_weighted) = split;

    if ($name eq $device) {
      close(IN);
      return ($s_read, $s_write);
    }

  }

  close(IN);
  unknown("Device $device not found");

}

#################################################
# reads kernel 2.4 disk stats
sub read_24 {

  my $device = shift;

  open(IN,"/proc/partitions") or
    unknown("Cannot open /proc/partitions");

  while(<IN>) {

    chomp;

    # kernel version 2.6

    # /proc/diskstats format
    #
    # major         Major number
    # minor         Minor number
    # blocks        Blocks
    # name          Name
    # reads         This is the total number of reads completed successfully.
    # merge_read    Reads and writes which are adjacent to each other may be merged for
    #               efficiency.  Thus two 4K reads may become one 8K read before it is
    #               ultimately handed to the disk, and so it will be counted (and queued)
    #               as only one I/O.  This field lets you know how often this was done.
    # s_read        This is the total number of sectors read successfully.
    # ms_read       This is the total number of milliseconds spent by all reads.
    # writes        This is the total number of writes completed successfully.
    # merge_write   Reads and writes which are adjacent to each other may be merged for
    #               efficiency.  Thus two 4K reads may become one 8K read before it is
    #               ultimately handed to the disk, and so it will be counted (and queued)
    #               as only one I/O.  This field lets you know how often this was done.
    # s_write       This is the total number of sectors written successfully.
    # ms_write      This is the total number of milliseconds spent by all writes.
    # ios           The only field that should go to zero. Incremented as requests are
    #               given to appropriate request_queue_t and decremented as they finish.
    # ms_io         This field is increases so long as field 9 is nonzero.
    # ms_weighted   This field is incremented at each I/O start, I/O completion, I/O
    #               merge, or read f these stats by the number of I/Os in progress
    #               times the number of milliseconds spent doing I/O since the
    #               last update of this field.  This can provide an easy measure of both
    #               I/O completion time and the backlog that may be accumulating.

    my ($major,
        $minor,
        $blocks,
        $name,
        $reads,
        $merge_read,
        $s_read,
        $ms_read,
        $writes,
        $merge_write,
        $s_write,
        $ms_write,
        $ios,
        $ms_io,
        $ms_weighted) = split;

    if ($name eq $device) {
      close(IN);
      return ($s_read, $s_write);
    }

  }

  close(IN);
  unknown("Device $device not found");

}

##############################################################################
# main
#

########################
# Command line arguments

$result = GetOptions (
    "critical=i"  => \$critical,
    "device=s"    => \$device,
    "help"        => \$help,
    "reset"       => \$reset,
    "silent"      => \$silent,
    "warning=i"   => \$warning,
    "version"     => sub { print "check_diskio version $VERSION\n"; exit 3;}
);

if (!$result) {
  usage();
}

my $version = kernel_version;


if ($help)                            { usage(); }
if (!$silent && $critical <= 0)       { usage("Could not parse \"critical\"");  }
if (!$device)                         { usage("Could not parse \"device\"");    }
if (!$silent && $warning  <= 0)       { usage("Could not parse \"warning\"");   }
if (!$silent && $critical < $warning) { usage("\"critical\" has to be greater than \"warning\""); }

# strip /dev/
$device =~ s/^\/dev\///;

# we need one temporary file per device
my ($controller, $disk) = split(/\//,$device);
if (!$disk) {
    $tmp = $tmp . "-$controller";
} else {
    $tmp = $tmp . "-$disk";
}

########################
# Check the proc entry

my $diff;
my $found  = 0;
my $in;
my $out;
my $time;

my $s_read;
my $s_write;

if ($version eq "2.6") {
  ($s_read, $s_write) = read_26($device);
}  elsif ($version eq "2.4") {
  ($s_read, $s_write) = read_24($device);
}

# get the time difference
if ($reset || !open(TMP, $tmp)) {
  write_timer($s_write, $s_read);
  unknown("Initializing timer");
}

while (<TMP>) {
  chomp;
  ($time, $in, $out) = split;
  $diff = time - $time;
}

close(TMP);

write_timer($s_write, $s_read);

if ($diff == 0) {
  # round up
  $diff = 1;
}

my $diskio_w;
my $diskio_r;

# check for overflows (2^32 sectors)
if ($s_write < $in) {
    # overflow
    $diskio_w = 4294967296 - $in + $s_write;
} else {
    $diskio_w = $s_write - $in;
}
if ($s_read < $out) {
    # overflow
    $diskio_r = 4294967296 - $out + $s_read;
} else {
    $diskio_r = $s_read - $out;
}

$diskio_w = int($diskio_w/ $diff);
$diskio_r = int($diskio_r/ $diff);

my $diskio   = $diskio_w + $diskio_r;

if ($silent) {
    print "$name OK $diskio sectors/s|TOTAL=$diskio;;;;"
        ." WRITE=$diskio_w;;;;"
        ." READ=$diskio_r;;;;"
        ." TIME=$diff;;;;\n";
    exit 0;
} else {
    my $performance = "TOTAL=$diskio;$warning;$critical;;"
        ." WRITE=$diskio_w;;;;"
        ." READ=$diskio_r;;;;"
        ." TIME=$diff;;;;";
    
    if ($diskio < $warning) {
        print "$name OK $diskio sectors/s|$performance\n";
        exit 0;
    } else {
        if ($diskio < $critical) {
            print "$name WARNING $diskio sectors/s|$performance\n";
            exit 1;
        } else {
            print "$name CRITICAL $diskio sectors/s|$performance\n";
            exit 2;
        }
    }
}

warning("Implementation error");
